{"version":3,"sources":["~lib/rt/common.ts","assembly/index.ts"],"names":[],"mappings":"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","sourceRoot":"./TinyBasic","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","type T = u16;\n\nconst CoreTop = 0x10000;      /* Core size */\nconst UserProg: T = 0x20;   /* Core address of front of Basic program */\nconst EndUser: T = 0x22;    /* Core address of end of stack/user space */\nconst EndProg: T = 0x24;    /* Core address of end of Basic program */\nconst GoStkTop: T = 0x26;   /* Core address of Gosub stack top */\nconst LinoCore: T = 0x28;   /* Core address of \"Current BASIC line number\" */\nconst ILPCcore: T = 0x2A;   /* Core address of \"IL Program Counter\" */\nconst BPcore: T = 0x2C;     /* Core address of \"Basic Pointer\" */\nconst SvPtCore: T = 0x2E;   /* Core address of \"Saved Pointer\" */\nconst InLine: T = 0x30;     /* Core address of input line */\nconst ExpnStk: T = 0x80;    /* Core address of expression stack (empty) */\nconst TabHere: T = 0xBF;    /* Core address of output line size, for tabs */\nconst WachPoint: T = 0xFF;  /* Core address of debug watchpoint USR */\nexport const ColdGo: T = 0x100;    /* Core address of nominal restart USR */\nconst WarmGo: T = 0x103;    /* Core address of nominal warm start USR */\nconst InchSub: T = 0x106;   /* Core address of nominal char input USR */\nconst OutchSub: T = 0x109;  /* Core address of nominal char output USR */\nconst BreakSub: T = 0x10c;  /* Core address of nominal break test USR */\nconst DumpSub: T = 0x111;   /* Core address of debug core dump USR */\nconst PeekSub: T = 0x114;   /* Core address of nominal byte peek USR */\nconst Peek2Sub: T = 0x115;  /* Core address of nominal 2-byte peek USR */\nconst PokeSub: T = 0x118;   /* Core address of nominal byte poke USR */\nconst TrLogSub: T = 0x11B;  /* Core address of debug trace log USR */\nconst BScode: T = 0x10F;    /* Core address of backspace code */\nconst CanCode: T = 0x110;   /* Core address of line cancel code */\nexport const ILfront: T = 0x11E;   /* Core address of IL code address */\nexport const BadOp: u8 = 0x0F;      /* illegal op, default IL code */\n\nconst DEBUGON = 1;\nconst LOGSIZE: T = 0x1000;\n\ndeclare function ScreenChar(ch: T): void;\ndeclare function KeyInChar(): T;\ndeclare function OutStr(theMsg: u8): void;\n\nlet Debugging = 0;\nconst DebugLog = CoreTop;\nlet LogHere: T = 0;\nlet Watcher: T = 0, Watchee: T;\n\nlet Lino: T, ILPC: T;       /* current line #, IL program counter */\nlet BP: T, SvPt: T;            /* current, saved TB parse pointer */\nlet SubStk: T, ExpnTop: T;                      /* stack pointers */\nlet InLend: T, SrcEnd: T;   /* current input line & TB source end */\nlet UserEnd: T;            /* end of IL code, start of execute loop */\nlet ILend: T, XQhere: T = 0;\nlet Broken = false;             /* =true to stop execution or listing */\n\n/************************* Memory Utilities.. *************************/\n\nexport function Poke2(loc: i32, valu: i32): void {\n    store<T>(loc, bswap<T>(valu as T));\n}\n\nfunction Peek2(loc: i32): T {\n    return bswap<T>(load<T>(loc));\n}\n\n@inline\nfunction Upper(ch: u8): u8 {\n    return ch & (u8(0x60) < ch && ch < u8(0x7B) ? u8(0x5F) : u8(0x7F));\n}\n\n/************************** I/O Utilities... **************************/\n\nfunction Ouch(ch: T): void {                 /* output char to stdout */\n    if (ch == 0x0D) {\n        store<u8>(TabHere, 0); /* keep count of how long this line is */\n        ScreenChar(0x0A);\n    }\n    else if (ch >= 0x20 && ch <= 0x7E) {  /* ignore non-print control */\n        store<u8>(TabHere, load<u8>(TabHere) + 1);\n        ScreenChar(ch);\n    }\n}\n\nfunction Inch(): T {       /* read input character from stdin or file */\n    let ch = KeyInChar();                     /* get input from stdin */\n    if (ch == 0x0A) {\n        ch = 0x0D;                 /* convert line end to TB standard */\n        store<u8>(TabHere, 0);                   /* reset tab counter */\n    }\n    return ch;\n}\n\nfunction StopIt(): bool {\n    return Broken;\n}\n\nfunction OutLn(): void {      /* terminate output line to the console */\n    Ouch(0x0D);\n}\n\nfunction OutInt(theNum: i32): void {  /* output a number to the console */\n    if (theNum < 0) {\n        Ouch(0x2D);\n        theNum = -theNum;\n    }\n    if (theNum > 9)\n        OutInt(theNum / 10);\n    Ouch(theNum % 10 + 0x30 as T);\n}\n\n/*********************** Debugging Utilities... ***********************/\n\nfunction OutHex(num: i32, nd: T): void { /* output hex num to console */\n    if (nd > 1)\n        OutHex(num >> 4, nd - 1);\n    num &= 0x0F;\n    Ouch(num + (num > 9 ? 0x37 : 0x30) as T);\n}\n\nfunction ShowSubs(): void { /* display subroutine stack for debugging */\n    let ix: T;\n    OutLn(); OutStr(0); OutHex(SubStk, 5);\n    for (ix = SubStk; ix < UserEnd; ix++) {\n        Ouch(0x20);\n        OutInt(Peek2(ix++));\n    }\n    Ouch(0x5D);\n}\n\nfunction ShowExSt(): void {   /* display expression stack for debugging */\n    let ix: T;\n    OutLn(); OutStr(1); OutHex(ExpnTop, 3);\n    if ((ExpnTop & 1) == 0)\n        for (ix = ExpnTop; ix < ExpnStk; ix++) {\n            Ouch(0x20);\n            OutInt(Peek2(ix++));\n        }\n    else\n        for (ix = ExpnTop; ix < ExpnStk; ix++) {\n            Ouch(0x2E);\n            OutInt(load<u8>(ix) as T);\n        }\n    Ouch(0x5D);\n}\n\nfunction ShowVars(whom: T): void {      /* display vars for debugging */\n    let ix: T, valu: T = 1, prior: T = 1;\n    if (whom == 0)\n        whom = 26;\n    else {\n        whom = (whom >> 1) & 0x1F;   /* whom is a specified var, or 0 */\n        valu = whom;\n    }\n    OutLn();\n    OutStr(2);\n    for (ix = valu; ix <= whom; ix++) {   /* all non-0 vars else whom */\n        valu = Peek2(ix * 2 + ExpnStk);\n        if (valu == 0 && prior == 0)              /* omit multiple 0s */\n            continue\n        prior = valu;\n        Ouch(0x0D);\n        Ouch(ix + 0x40);                             /* show var name */\n        Ouch(0x3D);                                              /* = */\n        OutInt(valu);\n    }\n    Ouch(0x5D);\n}\n\nfunction ShoMemDump(here: T, nlocs: T): void {/* display hex mem dump */\n    let temp: T, thar = here & 0xF0;\n    while (nlocs > 0) {\n        temp = thar;\n        OutLn();\n        OutHex(here, 4);\n        Ouch(0x3A); Ouch(0x20);\n        while (thar < here) {\n            Ouch(0x20); Ouch(0x20); Ouch(0x20);\n            thar++;\n        }\n        do {\n            Ouch(0x20);\n            if (nlocs-- > 0)\n                OutHex(load<u8>(here), 2);\n            else {\n                Ouch(0x20); Ouch(0x20);\n            }\n        }\n        while (++here % 0x10);\n        Ouch(0x20); Ouch(0x20);\n        while (temp < thar) { Ouch(0x20); temp++; }\n        while (thar < here && nlocs < 0 && ((thar & 0x0F) >= nlocs + 0x10)) {\n            temp = load<u8>(thar++);\n            Ouch(temp == 0x0D ? 0x5C : temp < 0x20 ? 0x60 : temp > 0x7E ? 0x7E : u8(temp));\n        }\n    }\n    OutLn();\n}\n\nfunction ShoLogVal(item: i32): void { /* format & output one activity log item */\n    let valu = load<i32>(item, DebugLog);\n    OutLn();\n    if (valu < -0x10000) {                       /* store to a variable */\n        Ouch(((valu >> 17) & 0x1F) + 0x40 as T);\n        Ouch(0x3D);\n        OutInt((valu & 0x7FFF) - (valu & 0x8000));\n    }\n    else if (valu < -0x8000) {                               /* error # */\n        OutStr(3);\n        OutInt(-valu - 0x8000);\n    }\n    else if (valu < 0) {               /* only logs IL sequence changes */\n        OutStr(4);\n        OutHex(-Peek2(ILfront) - valu, 3);\n    }\n    else if (valu < 0x10000) {                      /* TinyBasic line # */\n        Ouch(0x23);\n        OutInt(valu);\n    }\n    else {                                          /* poke memory byte */\n        Ouch(0x21);\n        OutHex(valu, 4);\n        Ouch(0x3D);\n        OutInt(valu >> 0x10);\n    }\n}\n\nfunction ShowLog(): void {        /* display activity log for debugging */\n    let ix: T;\n    OutLn();\n    OutStr(5);\n    OutInt(LogHere);\n    Ouch(0x20); Ouch(0x2A); Ouch(0x2A); Ouch(0x2A);           /* \" ***\" */\n    if (LogHere >= LOGSIZE)   /* circular, show only last 4K activities */\n        for (ix = (LogHere & (LOGSIZE - 1)); ix < LOGSIZE; ix++)\n            ShoLogVal(ix);\n    for (ix = 0; ix < (LogHere & (LOGSIZE - 1)); ix++)\n        ShoLogVal(ix);\n    OutLn();\n    Ouch(0x2A); Ouch(0x2A); Ouch(0x2A); Ouch(0x2A); Ouch(0x2A);/* ***** */\n    OutLn();\n}\n\nfunction LogIt(valu: i32): void {          /* insert this valu into activity log */\n    store<i32>(LogHere++ << 3, valu, DebugLog);\n}\n\n/************************ Utility functions... ************************/\n\nfunction WarmStart(): void {           /* initialize existing program */\n    UserEnd = Peek2(EndUser);\n    SubStk = UserEnd;          /* empty subroutine, expression stacks */\n    Poke2(GoStkTop, SubStk);\n    ExpnTop = ExpnStk;\n    Lino = 0;                                      /* not in any line */\n    ILPC = 0;                                    /* start IL at front */\n    SvPt = InLine;\n    BP = InLine;\n    load<u8>(BP, 0);\n    load<u8>(TabHere, 0);\n    InLend = InLine;\n}\n\nexport function ColdStart(ILend_: T): void {    /* initialize program to empty */\n    if (ILend_)\n        ILend = ILend_;\n    if (Peek2(ILfront) != ILfront + 2)\n        ILend = Peek2(ILfront) + 0x800;\n    Poke2(UserProg, (ILend + 0xFF) & 0xF0);   /* start Basic after IL */\n    if (CoreTop > 0xFFFF) {\n        Poke2(EndUser, 0xFFFE);\n        Poke2(0xFFFE, 0xDEAD);\n    }\n    else\n        Poke2(EndUser, CoreTop);\n    WarmStart();\n    SrcEnd = Peek2(UserProg);\n    Poke2(SrcEnd++, 0);\n    Poke2(EndProg, ++SrcEnd);\n}\n\nfunction TBerror(): void {                /* report interpreter error */\n    if (ILPC == 0)                             /* already reported it */\n        return;\n    OutLn();\n    LogIt(-ILPC - 0x8000);\n    OutStr(6);        /* IL address is the error # */\n    OutInt(ILPC - Peek2(ILfront));\n    if (Lino > 0) {                      /* Lino=0 if in command line */\n        OutStr(7);\n        OutInt(Lino);\n    }\n    OutLn();\n    if (Debugging > 0) {            /* some extra info if debugging.. */\n        ShowSubs();\n        ShowExSt();\n        ShowVars(0);\n        OutStr(8);\n        OutHex(BP, 4);\n        OutStr(9);\n        OutHex(Peek2(UserProg), 4);\n        OutStr(10);\n        OutHex(Peek2(ILfront), 4);\n        Ouch(0x5D);\n        ShoMemDump((BP - 30) & 0xFF00, 0x100);\n    }\n    Lino = 0;                         /* restart interpreter at front */\n    ExpnTop = ExpnStk;                 /* with empty expression stack */\n    ILPC = 0;     /* cheap error test; interp reloads it from ILfront */\n    BP = InLine;\n}\n\nfunction PushSub(valu: i32): void {    /* push value onto Gosub stack */\n    if (SubStk <= SrcEnd)\n        TBerror();\n    else {\n        SubStk -= 2;\n        Poke2(GoStkTop, SubStk);\n        Poke2(SubStk, valu);\n    }\n    if (Debugging > 0)\n        ShowSubs();\n}\n\nfunction PopSub(): T {                   /* pop value off Gosub stack */\n    if (SubStk >= Peek2(EndUser) - 1) {    /* underflow (empty stack) */\n        TBerror();\n        return 0xFFFF;\n    }\n    else {\n        if (Debugging > 0)\n            ShowSubs();\n        SubStk += 2;\n        Poke2(GoStkTop, SubStk);\n        return Peek2(SubStk - 2);\n    }\n}\n\nfunction PushExBy(valu: i32): void {   /* push byte onto expression stack */\n    if (ExpnTop <= InLend)\n        TBerror();\n    else\n        store<u8>(--ExpnTop, valu & u8(0xFF));\n    if (Debugging > 0)\n        ShowExSt();\n}\n\nfunction PopExBy(): u8 {               /* pop byte off expression stack */\n    if (ExpnTop < ExpnStk)\n        return load<u8>(ExpnTop++);\n    TBerror();                          /* underflow (nothing in stack) */\n    return 0xFF;\n}\n\nfunction PushExInt(valu: T): void { /* push integer onto expression stack */\n    ExpnTop -= 2;\n    if (ExpnTop < InLend)\n        TBerror();\n    else\n        Poke2(ExpnTop, valu);\n    if (Debugging > 0)\n        ShowExSt();\n}\n\nfunction PopExInt(): T {            /* pop integer off expression stack */\n    if (++ExpnTop < ExpnStk)\n        return Peek2((ExpnTop++) - 1);\n    TBerror();\n    return 0xFFFF;\n}\n\nfunction SkipTo(here: T, fch: u8): T { /* search for'd past next marker */\n    while (true) {\n        let ch = load<u8>(here++);                 /* look at next char */\n        if (ch == fch) return here;                           /* got it */\n        if (ch == 0) return --here;\n    }\n}\n\nfunction FindLine(theLine: T): T {    /* find theLine in TB source code */\n    let ix: T;\n    let here = Peek2(UserProg);                       /* start at front */\n    while (true) {\n        ix = Peek2(here++);\n        if (theLine <= ix || ix == 0)           /* found it or overshot */\n            return --here;\n        here = SkipTo(++here, 0x0D);        /* skip to end of this line */\n    }\n}\n\nfunction GoToLino(): void { /* find line # Lino and set BP to its front */\n    let here: i32;\n    if (Lino <= 0) {              /* Lino=0 is just command line (OK).. */\n        BP = InLine;\n        if (DEBUGON)\n            LogIt(0);\n        return;\n    }\n    if (DEBUGON)\n        LogIt(Lino);\n    if (Debugging > 0) {\n        Ouch(0x20); Ouch(0x5B); Ouch(0x23); OutInt(Lino); Ouch(0x5D);\n    }\n    BP = FindLine(Lino);                  /* otherwise try to find it.. */\n    here = Peek2(BP++);\n    if ((here == 0) || Lino != here)            /* ran off the end, error off */\n        TBerror();\n    else\n        BP++;\n}\n\nfunction ListIt(from: T, to: T): void {      /* list the stored program */\n    let ch: u8;\n    let here: T;\n    if (from == 0) {        /* 0,0 defaults to all; n,0 defaults to n,n */\n        to = 0xFFFF as T;\n        from = 1;\n    }\n    else if (to == 0)\n        to = from;\n    here = FindLine(from);                  /* try to find first line.. */\n    while (!StopIt()) {\n        from = Peek2(here++);          /* get this line's # to print it */\n        if (from > to || from == 0)\n            break;\n        here++;\n        OutInt(from);\n        Ouch(0x20);\n        do {                                            /* print the text */\n            ch = load<u8>(here++);\n            Ouch(ch);\n        }\n        while (ch > 0x0D);\n    }\n}\n\nfunction LineSwap(here: T): void {   /* swap SvPt/BP if here is not in InLine  */\n    if (here < InLine || here >= InLend) {\n        here = SvPt;\n        SvPt = BP;\n        BP = here;\n    }\n    else\n        SvPt = BP;\n}\n\nexport function Interp(): void {\n    let ch: T;  /* comments from TinyBasic Experimenter's Kit, pp.15-21 */\n    let op: T, ix: T, here: T, chpt: T;                        /* temps */\n    Broken = false;          /* initialize this for possible later test */\n    while (true) {\n        if (StopIt()) {\n            Broken = false;\n            OutLn();\n            OutStr(11);\n            TBerror();\n        }\n        if (ILPC == 0) {\n            ILPC = Peek2(ILfront);\n            if (DEBUGON) LogIt(-ILPC);\n            if (Debugging > 0) {\n                OutLn(); OutStr(12); OutHex(ILPC, 4); Ouch(0x5D);\n            }\n        }\n        if (DEBUGON) if (Watcher > 0) {             /* check watchpoint.. */\n            if (((Watchee < 0) && (Watchee + 0x100 + load<u8>(Watcher)) != 0)\n                || ((Watchee >= 0) && (Watchee == load<u8>(Watcher)))) {\n                OutLn();\n                OutStr(13);\n                OutHex(Watcher, 4);\n                Ouch(0x20); Ouch(0x3D); Ouch(0x20);\n                OutInt(load<u8>(Watcher) as T);\n                Ouch(0x20); Ouch(0x2A); Ouch(0x2A); Ouch(0x2A); Ouch(0x20);\n                Watcher = 0;\n                TBerror();\n                continue;\n            }\n        }\n        op = load<u8>(ILPC++);\n        if (Debugging > 0) {\n            OutLn(); OutStr(14); OutHex(ILPC - Peek2(ILfront) - 1, 3);\n            Ouch(0x3D); OutHex(op, 2); Ouch(0x5D);\n        }\n        switch (op >>> 5) {\n            default: switch (op) {\n                case 0x0F:\n                    TBerror();\n                    return;\n\n                /* SX n    00-07   Stack Exchange. */\n                /*                 Exchange the top byte of computational stack with  */\n                /* that \"n\" bytes into the stack. The top/left byte of the stack is   */\n                /* considered to be byte 0, so SX 0 does nothing.                     */\n                case 0x01: case 0x02: case 0x03: case 0x04: case 0x05: case 0x06: case 0x07:\n                    if (ExpnTop + op >= ExpnStk) {       /* swap is below stack depth */\n                        TBerror();\n                        return;\n                    }\n                    ix = load<u8>(ExpnTop);\n                    store<u8>(ExpnTop, load<u8>(ExpnTop + op));\n                    store<u8>(ExpnTop + op, ix);\n                    if (Debugging > 0) ShowExSt();\n                    break;\n\n                /* LB n    09nn    Push Literal Byte onto Stack.                      */\n                /*                 This adds one byte to the expression stack, which  */\n                /* is the second byte of the instruction. An error stop will occur if */\n                /* the stack overflows. */\n                case 0x09:\n                    PushExBy(load<u8>(ILPC++) as T);                  /* push IL byte */\n                    break;\n\n                /* LN n    0Annnn  Push Literal Number.                               */\n                /*                 This adds the following two bytes to the           */\n                /* computational stack, as a 16-bit number. Stack overflow results in */\n                /* an error stop. Numbers are assumed to be Big-Endian.               */\n                case 0x0A:\n                    PushExInt(Peek2(ILPC++));              /* get next 2 IL bytes */\n                    ILPC++;\n                    break;\n\n                /* DS      0B      Duplicate Top Number (two bytes) on Stack.         */\n                /*                 An error stop will occur if there are less than 2  */\n                /* bytes (1 int) on the expression stack or if the stack overflows.   */\n                case 0x0B:\n                    op = ExpnTop;\n                    ix = PopExInt();\n                    if (ILPC == 0) break;                            /* underflow */\n                    ExpnTop = op;\n                    PushExInt(ix);\n                    break;\n\n                /* SP      0C      Stack Pop.                                         */\n                /*                 The top two bytes are removed from the expression  */\n                /* stack and discarded. Underflow results in an error stop.           */\n                case 0x0C:\n                    ix = PopExInt();\n                    if (Debugging > 0) ShowExSt();\n                    break;\n\n                /* SB      10      Save BASIC Pointer.                                */\n                /*                 If BASIC pointer is pointing into the input line   */\n                /* buffer, it is copied to the Saved Pointer; otherwise the two       */\n                /* pointers are exchanged.                                            */\n                case 0x10:\n                    LineSwap(BP);\n                    break;\n\n                /* RB      11      Restore BASIC Pointer.                             */\n                /*                 If the Saved Pointer points into the input line    */\n                /* buffer, it is replaced by the value in the BASIC pointer;          */\n                /* otherwise the two pointers are exchanged.                          */\n                case 0x11:\n                    LineSwap(SvPt);\n                    break;\n\n                /* FV      12      Fetch Variable.                                    */\n                /*                 The top byte of the computational stack is used to */\n                /* index into Page 00. It is replaced by the two bytes fetched. Error */\n                /* stops occur with stack overflow or underflow.                      */\n                case 0x12:\n                    op = PopExBy();\n                    if (ILPC != 0) PushExInt(Peek2(op));\n                    if (Debugging > 1) ShowVars(op);\n                    break;\n\n                /* SV      13      Store Variable.                                    */\n                /*                 The top two bytes of the computational stack are   */\n                /* stored into memory at the Page 00 address specified by the third   */\n                /* byte on the stack. All three bytes are deleted from the stack.     */\n                /* Underflow results in an error stop.                                */\n                case 0x13:\n                    ix = PopExInt();\n                    op = PopExBy();\n                    if (ILPC == 0) break;\n                    Poke2(op, ix);\n                    if (DEBUGON) LogIt((ix & 0xFFFF) + ((op - 0x100) << 0x10));\n                    if (Debugging > 0) { ShowVars(op); if (Debugging > 1) ShowExSt(); }\n                    break;\n\n                /* GS      14      GOSUB Save.                                        */\n                /*                 The current BASIC line number is pushed            */\n                /* onto the BASIC region of the control stack. It is essential that   */\n                /* the IL stack be empty for this to work properly but no check is    */\n                /* made for that condition. An error stop occurs on stack overflow.   */\n                case 0x14:\n                    PushSub(Lino);                   /* push line # (possibly =0) */\n                    break;\n\n                /* RS      15      Restore Saved Line.                                */\n                /*                 Pop the top two bytes off the BASIC region of the  */\n                /* control stack, making them the current line number. Set the BASIC  */\n                /* pointer at the beginning of that line. Note that this is the line  */\n                /* containing the GOSUB which caused the line number to be saved. As  */\n                /* with the GS opcode, it is essential that the IL region of the      */\n                /* control stack be empty. If the line number popped off the stack    */\n                /* does not correspond to a line in the BASIC program an error stop   */\n                /* occurs. An error stop also results from stack underflow.           */\n                case 0x15:\n                    Lino = PopSub();         /* get line # (possibly =0) from pop */\n                    if (ILPC != 0) GoToLino();             /* stops run if error */\n                    break;\n\n                /* GO      16      GOTO.                                              */\n                /*                 Make current the BASIC line whose line number is   */\n                /* equal to the value of the top two bytes in the expression stack.   */\n                /* That is, the top two bytes are popped off the computational stack, */\n                /* and the BASIC program is searched until a matching line number is  */\n                /* found. The BASIC pointer is then positioned at the beginning of    */\n                /* that line and the RUN mode flag is turned on. Stack underflow and  */\n                /* non-existent BASIC line result in error stops.                     */\n                case 0x16:\n                    ILPC = XQhere;                /* the IL assumes an implied NX */\n                    if (DEBUGON) LogIt(-ILPC);\n                    Lino = PopExInt();\n                    if (ILPC != 0) GoToLino();             /* stops run if error */\n                    break;\n\n                /* NE      17      Negate (two's complement).                         */\n                /*                 The number in the top two bytes of the expression  */\n                /* stack is replaced with its negative.                               */\n                case 0x17:\n                    ix = PopExInt();\n                    if (ILPC != 0) PushExInt(-ix);\n                    break;\n\n                /* AD      18      Add.                                               */\n                /*                 Add the two numbers represented by the top four    */\n                /* bytes of the expression stack, and replace them with the two-byte  */\n                /* sum. Stack underflow results in an error stop.                     */\n                case 0x1B:\n                    ix = PopExInt();\n                    op = PopExInt();\n                    if (ILPC != 0) PushExInt(op + ix);\n                    break;\n\n                /* SU      19      Subtract.                                          */\n                /*                 Subtract the two-byte number on the top of the     */\n                /* expression stack from the next two bytes and replace the 4 bytes   */\n                /* with the two-byte difference.                                      */\n                case 0x19:\n                    ix = PopExInt();\n                    op = PopExInt();\n                    if (ILPC != 0) PushExInt(op - ix);\n                    break;\n\n                /* MP      1A      Multiply.                                          */\n                /*                 Multiply the two numbers represented by the top 4  */\n                /* bytes of the computational stack, and replace them with the least  */\n                /* significant 16 bits of the product. Stack underflow is possible.   */\n                case 0x1A:\n                    ix = PopExInt();\n                    op = PopExInt();\n                    if (ILPC != 0) PushExInt(op * ix);\n                    break;\n\n                /* DV      1B      Divide.                                            */\n                /*                 Divide the number represented by the top two bytes */\n                /* of the computational stack into that represented by the next two.  */\n                /* Replace the 4 bytes with the quotient and discard the remainder.   */\n                /* This is a signed (two's complement) integer divide, resulting in a */\n                /* signed integer quotient. Stack underflow or attempted division by  */\n                /* zero result in an error stop. */\n                case 0x1B:\n                    ix = PopExInt();\n                    op = PopExInt();\n                    if (ix == 0) TBerror();                      /* divide by 0.. */\n                    else if (ILPC != 0) PushExInt(op / ix);\n                    break;\n\n                /* CP      1C      Compare.                                           */\n                /*                 The number in the top two bytes of the expression  */\n                /* stack is compared to (subtracted from) the number in the 4th and   */\n                /* fifth bytes of the stack, and the result is determined to be       */\n                /* Greater, Equal, or Less. The low three bits of the third byte mask */\n                /* a conditional skip in the IL program to test these conditions; if  */\n                /* the result corresponds to a one bit, the next byte of the IL code  */\n                /* is skipped and not executed. The three bits correspond to the      */\n                /* conditions as follows:                                             */\n                /*         bit 0   Result is Less                                     */\n                /*         bit 1   Result is Equal                                    */\n                /*         bit 2   Result is Greater                                  */\n                /* Whether the skip is taken or not, all five bytes are deleted from  */\n                /* the stack. This is a signed (two's complement) comparison so that  */\n                /* any positive number is greater than any negative number. Multiple  */\n                /* conditions, such as greater-than-or-equal or unequal (i.e.greater- */\n                /* than-or-less-than), may be tested by forming the condition mask    */\n                /* byte of the sum of the respective bits. In particular, a mask byte */\n                /* of 7 will force an unconditional skip and a mask byte of 0 will    */\n                /* force no skip. The other 5 bits of the control byte are ignored.   */\n                /* Stack underflow results in an error stop.                          */\n                case 0x1C:\n                    ix = PopExInt();\n                    op = PopExBy();\n                    ix = PopExInt() - ix;                           /* <0 or =0 or >0 */\n                    if (ILPC == 0) return;                             /* underflow.. */\n                    if (ix < 0) ix = 1;\n                    else if (ix > 0) ix = 4;                /* choose the bit to test */\n                    else ix = 2;\n                    if ((ix & op) > 0) ILPC++;           /* skip next IL op if bit =1 */\n                    if (Debugging > 0) ShowExSt();\n                    break;\n\n                /* NX      1D      Next BASIC Statement.                              */\n                /*                 Advance to next line in the BASIC program, if in   */\n                /* RUN mode, or restart the IL program if in the command mode. The    */\n                /* remainder of the current line is ignored. In the Run mode if there */\n                /* is another line it becomes current with the pointer positioned at  */\n                /* its beginning. At this time, if the Break condition returns true,  */\n                /* execution is aborted and the IL program is restarted after         */\n                /* printing an error message. Otherwise IL execution proceeds from    */\n                /* the saved IL address (see the XQ instruction). If there are no     */\n                /* more BASIC statements in the program an error stop occurs.         */\n                case 0x1D:\n                    if (Lino == 0) ILPC = 0;\n                    else {\n                        BP = SkipTo(BP, 0x0D);            /* skip to end of this line */\n                        Lino = Peek2(BP++);                             /* get line # */\n                        if (Lino == 0) {                           /* ran off the end */\n                            TBerror();\n                            break;\n                        }\n                        else\n                            BP++;\n                        ILPC = XQhere;            /* restart at saved IL address (XQ) */\n                        if (DEBUGON) LogIt(-ILPC);\n                    }\n                    if (DEBUGON) LogIt(Lino);\n                    if (Debugging > 0) {\n                        Ouch(0x20); Ouch(0x5B); Ouch(0x23); OutInt(Lino); Ouch(0x5D);\n                    }\n                    break;\n\n                /* LS      1F      List The Program.                                  */\n                /*                 The expression stack is assumed to have two 2-byte */\n                /* numbers. The top number is the line number of the last line to be  */\n                /* listed, and the next is the line number of the first line to be    */\n                /* listed. If the specified line numbers do not exist in the program, */\n                /* the next available line (i.e. with the next higher line number) is */\n                /* assumed instead in each case. If the last line to be listed comes  */\n                /* before the first, no lines are listed. If Break condition comes    */\n                /* true during a List operation, the remainder of the listing is      */\n                /* aborted. Zero is not a valid line number, and an error stop occurs */\n                /* if either line number specification is zero. The line number       */\n                /* specifications are deleted from the stack.                         */\n                case 0x1F:\n                    op = 0;\n                    ix = 0;              /* The IL seems to assume we can handle zero */\n                    while (ExpnTop < ExpnStk) {     /* or more numbers, so get them.. */\n                        op = ix;\n                        ix = PopExInt();\n                    }       /* get final line #, then initial.. */\n                    if (op < 0 || ix < 0) TBerror();\n                    else ListIt(ix, op);\n                    break;\n\n                /* PN      20      Print Number.                                      */\n                /*                 The number represented by the top two bytes of the */\n                /* expression stack is printed in decimal with leading zero           */\n                /* suppression. If it is negative, it is preceded by a minus sign     */\n                /* and the magnitude is printed. Stack underflow is possible.         */\n                case 0x20:\n                    ix = PopExInt();\n                    if (ILPC)\n                        OutInt(ix);\n                    break;\n\n                /* PQ      21      Print BASIC String.                                */\n                /*                 The ASCII characters beginning with the current    */\n                /* position of BASIC pointer are printed on the console. The string   */\n                /* to be printed is terminated by quotation mark (\"), and the BASIC   */\n                /* pointer is left at the character following the terminal quote. An  */\n                /* error stop occurs if a carriage return is imbedded in the string.  */\n                case 0x21:\n                    while (true) {\n                        ch = load<u8>(BP++);\n                        if (ch == 0x20) break;                 /* done on final quote */\n                        if (ch < 0x20) {     /* error if return or other control char */\n                            TBerror();\n                            break;\n                        }\n                        Ouch(ch);\n                    }                                      /* print it */\n                    break;\n\n                /* PT      22      Print Tab.                                         */\n                /*                 Print one or more spaces on the console, ending at */\n                /* the next multiple of eight character positions (from the left      */\n                /* margin).                                                           */\n                case 0x22:\n                    do { Ouch(0x20); } while (load<u8>(TabHere) % 8 > 0);\n                    break;\n\n                /* NL      23      New Line.                                          */\n                /*                 Output a carriage-return-linefeed sequence to the  */\n                /* console.                                                           */\n                case 0x23:\n                    Ouch(0x0D);\n                    break;\n\n                /* PC \"xxxx\"  24xxxxxxXx   Print Literal String.                      */\n                /*                         The ASCII string follows opcode and its    */\n                /* last byte has the most significant bit set to one.                 */\n                case 0x24:\n                    do {\n                        ix = load<u8>(ILPC++);\n                        Ouch(ix & 0x7F);                 /* strip high bit for output */\n                    } while ((ix & 0x80) == 0);\n                    break;\n\n                /* GL      27      Get Input Line.                                    */\n                /*                 ASCII characters are accepted from console input   */\n                /* to fill the line buffer. If the line length exceeds the available  */\n                /* space, the excess characters are ignored and bell characters are   */\n                /* output. The line is terminated by a carriage return. On completing */\n                /* one line of input, the BASIC pointer is set to point to the first  */\n                /* character in the input line buffer, and a carriage-return-linefeed */\n                /* sequence is [not] output.                                          */\n                case 0x27:\n                    InLend = InLine;\n                    while (true) {                   /* read input line characters... */\n                        ch = Inch();\n                        if (ch == 0x0D) break;                     /* end of the line */\n                        else if (ch == 0x09) {\n                            Debugging = (Debugging + DEBUGON) & 1;   /* toggle debug? */\n                            ch = 0x20;\n                        }                                    /* convert tabs to space */\n                        else if (ch == load<u8>(BScode)) {          /* backspace code */\n                            if (InLend > InLine) InLend--;  /* assume console already */\n                            else {   /* backing up over front of line: just kill it.. */\n                                Ouch(0x0D);\n                                break;\n                            }\n                        }\n                        else if (ch == load<u8>(CanCode)) {       /* cancel this line */\n                            InLend = InLine;\n                            Ouch(0x0D);                /* also start a new input line */\n                            break;\n                        }\n                        else if (ch < 0x20)            /* ignore non-ASCII & controls */\n                            continue;\n                        else if (ch > 0x7E)\n                            continue;\n                        if (InLend > ExpnTop - 2)            /* discard overrun chars */\n                            continue;\n                        store<u8>(InLend++, ch);\n                    }                                   /* insert this char in buffer */\n                    while (InLend > InLine && load<u8>(InLend - 1) == 0x20)\n                        InLend--;                    /* delete excess trailing spaces */\n                    store<u8>(InLend++, 0x0D);          /* insert final return & null */\n                    store<u8>(InLend, 0);\n                    BP = InLine;\n                    break;\n\n                /* IL      2A      Insert BASIC Line.                                 */\n                /*                 Beginning with the current position of the BASIC   */\n                /* pointer and continuing to the [end of it], the line is inserted    */\n                /* into the BASIC program space; for a line number, the top two bytes */\n                /* of the expression stack are used. If this number matches a line    */\n                /* already in the program it is deleted and the new one replaces it.  */\n                /* If the new line consists of only a carriage return, it is not      */\n                /* inserted, though any previous line with the same number will have  */\n                /* been deleted. The lines are maintained in the program space sorted */\n                /* by line number. If the new line to be inserted is a different size */\n                /* than the old line being replaced, the remainder of the program is  */\n                /* shifted over to make room or to close up the gap as necessary. If  */\n                /* there is insufficient memory to fit in the new line, the program   */\n                /* space is unchanged and an error stop occurs (with the IL address   */\n                /* decremented). A normal error stop occurs on expression stack       */\n                /* underflow or if the number is zero, which is not a valid line      */\n                /* number. After completing the insertion, the IL program is          */\n                /* restarted in the command mode.                                     */\n                case 0x2A:\n                    Lino = PopExInt();                                  /* get line # */\n                    if (Lino <= 0) {              /* don't insert line #0 or negative */\n                        if (ILPC != 0) TBerror();\n                        else return;\n                        break;\n                    }\n                    while (load<u8>(BP) == 0x20)               /* skip leading spaces */\n                        BP++;\n                    if (load<u8>(BP) == 0x0D)                       /* nothing to add */\n                        ix = 0;\n                    else\n                        ix = InLend - BP + 2;            /* the size of the insertion */\n                    op = 0;             /* this will be the number of bytes to delete */\n                    chpt = FindLine(Lino);                 /* try to find this line.. */\n                    if (Peek2(chpt) == Lino)           /* there is a line to delete.. */\n                        op = (SkipTo(chpt + 2, 0x0D) - chpt);\n                    if (ix == 0) if (op == 0) {    /* nothing to add nor delete; done */\n                        Lino = 0;\n                        break;\n                    }\n                    op = ix - op;        /* = how many more bytes to add or (-)delete */\n                    if (SrcEnd + op >= SubStk) {                         /* too big.. */\n                        TBerror();\n                        break;\n                    }\n                    SrcEnd = SrcEnd + op;                                 /* new size */\n                    if (op > 0)                        /* shift backend over to right */\n                        for (here = SrcEnd; (here--) > chpt + ix;)\n                            store<u8>(here, load<u8>(here - op));\n                    else if (op < 0)                    /* shift it left to close gap */\n                        for (here = chpt + ix; here < SrcEnd; here++)\n                            store<u8>(here, load<u8>(here - op));\n                    if (ix > 0) Poke2(chpt++, Lino);         /* insert the new line # */\n                    while (ix > 2) {                         /* insert the new line.. */\n                        store<u8>(++chpt, load<u8>(BP++));\n                        ix--;\n                    }\n                    Poke2(EndProg, SrcEnd);\n                    ILPC = 0;\n                    Lino = 0;\n                    if (Debugging > 0) ListIt(0, 0);\n                    break;\n\n                /* MT      2B      Mark the BASIC program space Empty.                */\n                /*                 Also clears the BASIC region of the control stack  */\n                /* and restart the IL program in the command mode. The memory bounds  */\n                /* and stack pointers are reset by this instruction to signify empty  */\n                /* program space, and the line number of the first line is set to 0,  */\n                /* which is the indication of the end of the program.                 */\n                case 0x2B:\n                    ColdStart(0);\n                    if (Debugging > 0) { ShowSubs(); ShowExSt(); ShowVars(0); }\n                    break;\n\n                /* XQ      2C      Execute.                                           */\n                /*                 Turns on RUN mode. This instruction also saves     */\n                /* the current value of the IL program counter for use of the NX      */\n                /* instruction, and sets the BASIC pointer to the beginning of the    */\n                /* BASIC program space. An error stop occurs if there is no BASIC     */\n                /* program. This instruction must be executed at least once before    */\n                /* the first execution of a NX instruction.                           */\n                case 0x2C:\n                    XQhere = ILPC;\n                    BP = Peek2(UserProg);\n                    Lino = Peek2(BP++);\n                    BP++;\n                    if (Lino == 0) TBerror();\n                    else if (Debugging > 0) {\n                        Ouch(0x20); Ouch(0x5B); Ouch(0x23); OutInt(Lino); Ouch(0x5D);\n                    }\n                    break;\n\n                /* WS      2D      Stop.                                              */\n                /*                 Stop execution and restart the IL program in the   */\n                /* command mode. The entire control stack (including BASIC region)    */\n                /* is also vacated by this instruction. This instruction effectively  */\n                /* jumps to the Warm Start entry of the ML interpreter.               */\n                case 0x2D:\n                    WarmStart();\n                    if (Debugging > 0) ShowSubs();\n                    break;\n\n                /* US      2E      Machine Language Subroutine Call.                  */\n                /*                 The top six bytes of the expression stack contain  */\n                /* 3 numbers with the following interpretations: The top number is    */\n                /* loaded into the A (or A and B) register; the next number is loaded */\n                /* into 16 bits of Index register; the third number is interpreted as */\n                /* the address of a machine language subroutine to be called. These   */\n                /* six bytes on the expression stack are replaced with the 16-bit     */\n                /* result returned by the subroutine. Stack underflow results in an   */\n                /* error stop.                                                        */\n                case 0x2E:\n                    Poke2(LinoCore, Lino);       /* bring these memory locations up.. */\n                    Poke2(ILPCcore, ILPC);         /* ..to date, in case user looks.. */\n                    Poke2(BPcore, BP);\n                    Poke2(SvPtCore, SvPt);\n                    ix = PopExInt() /* & 0xFFFF */;                        /* datum A */\n                    here = PopExInt() /* & 0xFFFF */;                      /* datum X */\n                    op = PopExInt() /* & 0xFFFF */;        /* nominal machine address */\n                    if (ILPC == 0) break;\n                    if (op >= Peek2(ILfront) && op < ILend) { /* call IL subroutine.. */\n                        PushExInt(here);\n                        PushExInt(ix);\n                        PushSub(ILPC);                        /* push return location */\n                        ILPC = op;\n                        if (DEBUGON) LogIt(-ILPC);\n                        break;\n                    }\n                    switch (op) {\n                        case WachPoint:    /* we only do a few predefined functions.. */\n                            Watcher = here;\n                            if (ix > 0x7FFF) ix = -load<u8>(here) - 0x100;\n                            Watchee = ix;\n                            if (Debugging > 0) {\n                                OutLn(); OutStr(15); OutHex(here, 4); Ouch(0x5D);\n                            }\n                            PushExInt(load<u8>(here));\n                            break;\n                        case ColdGo:\n                            ColdStart(0);\n                            break;\n                        case WarmGo:\n                            WarmStart();\n                            break;\n                        case InchSub:\n                            PushExInt(Inch());\n                            break;\n                        case OutchSub:\n                            Ouch(u8(ix & 0x7F));\n                            PushExInt(0);\n                            break;\n                        case BreakSub:\n                            PushExInt(StopIt() as T);\n                            break;\n                        case PeekSub:\n                            PushExInt(load<u8>(here) as T);\n                            break;\n                        case Peek2Sub:\n                            PushExInt(Peek2(here));\n                            break;\n                        case PokeSub:\n                            ix = ix & 0xFF;\n                            store<u8>(here, u8(ix));\n                            PushExInt(ix);\n                            if (DEBUGON) LogIt(((ix + 0x100) << 16) + here);\n                            Lino = Peek2(LinoCore);       /* restore these pointers.. */\n                            ILPC = Peek2(ILPCcore);  /* ..in case user changed them.. */\n                            BP = Peek2(BPcore);\n                            SvPt = Peek2(SvPtCore);\n                            break;\n                        case DumpSub:\n                            ShoMemDump(here, ix);\n                            PushExInt(here + ix);\n                            break;\n                        case TrLogSub:\n                            ShowLog();\n                            PushExInt(LogHere);\n                            break;\n                        default: TBerror();\n                    }\n                    break;\n\n                /* RT      2F      IL Subroutine Return.                              */\n                /*                 The IL control stack is popped to give the address */\n                /* of the next IL instruction. An error stop occurs if the entire     */\n                /* control stack (IL and BASIC) is empty.                             */\n                case 0x2F:\n                    ix = PopSub();                             /* get return from pop */\n                    if (ix < Peek2(ILfront) || ix >= ILend) TBerror();\n                    else if (ILPC != 0) {\n                        ILPC = ix;\n                        if (DEBUGON) LogIt(-ILPC);\n                    }\n                    break;\n\n                /* JS a    3000-37FF       IL Subroutine Call.                        */\n                /*                         The least significant eleven bits of this  */\n                /* 2-byte instruction are added to the base address of the IL program */\n                /* to become address of the next instruction. The previous contents   */\n                /* of the IL program counter are pushed onto the IL region of the     */\n                /* control stack. Stack overflow results in an error stop.            */\n                case 0x30: case 0x31: case 0x32: case 0x33: case 0x34: case 0x35: case 0x36: case 0x37:\n                    PushSub(ILPC + 1);                  /* push return location there */\n                    if (ILPC == 0) break;\n                    ILPC = (Peek2(ILPC - 1) & 0x7FF) + Peek2(ILfront);\n                    if (DEBUGON) LogIt(-ILPC);\n                    break;\n\n                /* J a     3800-3FFF       Jump.                                      */\n                /*                         The low eleven bits of this 2-byte         */\n                /* instruction are added to the IL program base address to determine  */\n                /* the address of the next IL instruction. The previous contents of   */\n                /* the IL program counter is lost. */\n                case 0x38: case 0x39: case 0x3A: case 0x3B: case 0x3C: case 0x3D: case 0x3E: case 0x3F:\n                    ILPC = (Peek2(ILPC - 1) & 0x7FF) + Peek2(ILfront);\n                    if (DEBUGON) LogIt(-ILPC);\n                    break;\n\n                /* NO      08      No Operation.                                      */\n                /*                 This may be used as a space filler (such as to     */\n                /* ignore a skip).                                                    */\n                default:\n                    break;\n            } /* last of inner switch cases */\n                break; /* end of outer switch cases 0,1 */\n\n            /* BR a    40-7F   Relative Branch.                                   */\n            /*                 The low six bits of this instruction opcode are    */\n            /* added algebraically to the current value of the IL program counter */\n            /* to give the address of the next IL instruction. Bit 5 of opcode is */\n            /* the sign, with + signified by 1, - by 0. The range of this branch  */\n            /* is +/-31 bytes from address of the byte following the opcode. An   */\n            /* offset of zero (i.e. opcode 60) results in an error stop. The      */\n            /* branch operation is unconditional.                                 */\n            case 0x02: case 0x03:\n                ILPC = ILPC + op - 0x60;\n                if (DEBUGON) LogIt(-ILPC);\n                break;\n\n            /* BC a \"xxx\"   80xxxxXx-9FxxxxXx  String Match Branch.               */\n            /*                                 The ASCII character string in IL   */\n            /* following this opcode is compared to the string beginning with the */\n            /* current position of the BASIC pointer, ignoring blanks in BASIC    */\n            /* program. The comparison continues until either a mismatch, or an   */\n            /* IL byte is reached with the most significant bit set to one. This  */\n            /* is the last byte of the string in the IL, compared as a 7-bit      */\n            /* character; if equal, the BASIC pointer is positioned after the     */\n            /* last matching character in the BASIC program and the IL continues  */\n            /* with the next instruction in sequence. Otherwise the BASIC pointer */\n            /* is not altered and the low five bits of the Branch opcode are      */\n            /* added to the IL program counter to form the address of the next    */\n            /* IL instruction. If the strings do not match and the branch offset  */\n            /* is zero an error stop occurs.                                      */\n            case 0x04:\n                if (op == 0x80) here = 0;                     /* to error if no match */\n                else here = ILPC + (op & 0x7F);\n                chpt = BP;\n                ix = 0;\n                while ((ix & 0x80) == 0) {\n                    while (load<u8>(BP) == 0x20) BP++;            /* skip over spaces */\n                    ix = load<u8>(ILPC++);\n                    if ((ix & 0x7F) != Upper(load<u8>(BP++))) {\n                        BP = chpt;             /* back up to front of string in Basic */\n                        if (here == 0) TBerror();\n                        else ILPC = here;                       /* jump forward in IL */\n                        break;\n                    }\n                }\n                if (DEBUGON) if (ILPC > 0) LogIt(-ILPC);\n                break;\n\n            /* BV a    A0-BF   Branch if Not Variable.                            */\n            /*                 If the next non-blank character pointed to by the  */\n            /* BASIC pointer is a capital letter, its ASCII code is [doubled and] */\n            /* pushed onto the expression stack and the IL program advances to    */\n            /* next instruction in sequence, leaving the BASIC pointer positioned */\n            /* after the letter; if not a letter the branch is taken and BASIC    */\n            /* pointer is left pointing to that character. An error stop occurs   */\n            /* if the next character is not a letter and the offset of the branch */\n            /* is zero, or on stack overflow.                                     */\n            case 0x05:\n                while (load<u8>(BP) == 0x20) BP++;                /* skip over spaces */\n                ch = load<u8>(BP);\n                if (ch > 0x30 && ch <= 0x5A || ch > 0x60 && ch <= 0x7A)\n                    PushExBy((load<u8>(BP++) & 0x5F) * 2);\n                else if (op == 0xA0) TBerror();           /* error if not letter */\n                else ILPC = ILPC + op - 0xA0;\n                if (DEBUGON) if (ILPC > 0) LogIt(-ILPC);\n                break;\n\n            /* BN a    C0-DF   Branch if Not a Number.                            */\n            /*                 If the next non-blank character pointed to by the  */\n            /* BASIC pointer is not a decimal digit, the low five bits of the     */\n            /* opcode are added to the IL program counter, or if zero an error    */\n            /* stop occurs. If the next character is a digit, then it and all     */\n            /* decimal digits following it (ignoring blanks) are converted to a   */\n            /* 16-bit binary number which is pushed onto the expression stack. In */\n            /* either case the BASIC pointer is positioned at the next character  */\n            /* which is neither blank nor digit. Stack overflow will result in an */\n            /* error stop.                                                        */\n            case 0x06:\n                while (load<u8>(BP) == 0x20) BP++;                /* skip over spaces */\n                ch = load<u8>(BP);\n                if (ch >= 0x30 && ch < 0x40) {\n                    op = 0;\n                    while (true) {\n                        here = load<u8>(BP++);\n                        if (here == 0x20)                         /* skip over spaces */\n                            continue;\n                        if (here < 0x30 || here > 0x39)        /* not a decimal digit */\n                            break;\n                        op = op * 10 + (here & 0x0F);\n                    }                                            /* insert into value */\n                    BP--;                                   /* back up over non-digit */\n                    PushExInt(op);\n                }\n                else if (op == 0xC0)                             /* error if no digit */\n                    TBerror();\n                else\n                    ILPC = ILPC + op - 0xC0;\n                if (DEBUGON) if (ILPC > 0) LogIt(-ILPC);\n                break;\n\n            /* BE a    E0-FF   Branch if Not Endline.                             */\n            /*                 If the next non-blank character pointed to by the  */\n            /* BASIC pointer is a carriage return, the IL program advances to the */\n            /* next instruction in sequence; otherwise the low five bits of the   */\n            /* opcode (if not 0) are added to the IL program counter to form the  */\n            /* address of next IL instruction. In either case the BASIC pointer   */\n            /* is left pointing to the first non-blank character; this            */\n            /* instruction will not pass over the carriage return, which must     */\n            /* remain for testing by the NX instruction. As with the other        */\n            /* conditional branches, the branch may only advance the IL program   */\n            /* counter from 1 to 31 bytes; an offset of zero results in an error  */\n            /* stop.                                                              */\n            case 0x07:\n                while (load<u8>(BP) == 0x20) BP++;                /* skip over spaces */\n                if (load<u8>(BP) == 0x0D)\n                    BP = BP;\n                else if (op == 0xE0)                         /* error if no offset */\n                    TBerror();\n                else\n                    ILPC = ILPC + op - 0xE0;\n                if (DEBUGON) if (ILPC > 0) LogIt(-ILPC);\n                break;\n        }\n    }\n}\n"]}