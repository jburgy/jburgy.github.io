{"version":3,"sources":["~lib/rt/common.ts","assembly/index.ts"],"names":[],"mappings":"mICiFE,EAZA,AAAQ,IAER,AAAK,UAUoB,KAAkB,GAAK,aACzC,AAAgB,AAAmB,EAAK,GAAxB,EAAI,IAApB,EAAK,OACZ,AAAU,GAAG,KACN,OASP,AAAI,AADM,IACD,KAAoB,MAK7B,AAAI,MAAK,KAAmB,KACrB,KAXQ,IAsEC,UAAM,IAAb,KAAqB,KACd,UAAM,IAAb,KAAqB,KACvB,UA1GkB,qBAClB,AAAI,MAAG,EAAK,AAAS,QACxB,AAAI,AAAC,KAAU,EAAI,GAAI,KACV,mBAFe,AAAE,WAIhC,EAAO,IACQ,2BAEjB,AAAI,IACJ,AAAI,AAAE,SACN,EAAoB,mBAAgB,YAAK,WAClC,KAsHP,AAAI,AAAC,UAAU,IACf,AAAI,AAAK,AAlCM,AAAK,AAAL,AAAK,EAAK,IAAV,QAAU,IAAV,QAkCX,UAAyB,AA9Bd,AAAK,AAJL,AAAK,EAAK,IAAV,QAIS,GAAK,IAAd,UA+BR,AAAM,EAAG,AA/BD,AAAK,EAAI,GAAK,IAAd,aAmCf,AAAI,AAAK,AAvCM,AAAK,AAAL,AAAK,EAAK,IAAV,QAAU,IAAV,QAuCO,OACb,AAAK,AAxCC,AAAK,AAIL,AAAK,AAJL,AAAK,EAAK,IAAV,QAIS,GAAK,IAAd,QAJU,IAAV,QAwCiB,KAEvB,AAAM,AAtCA,AAAK,EAAI,GAAK,IAAd,QAsCQ,UAvBnB,KAEU,AADM,AApBL,AAAK,EAAK,IAAV,QAoBa,MACX,AAAM,AAjBR,AAAK,EAAI,GAAK,IAAd,QAiBgB,MAbf,UAAM,IAAb,KAAqB,KACd,UAAM,IAAb,KAAqB,KAYrB,GAEA,SAKF,KAAc,AA5BN,AAAK,EAAK,IAAV,UA4Bc,AA5Bd,AAAK,EAAK,IAAV,UAQC,UAAM,IAAb,KAAqB,KACd,UAAM,IAAb,KAAqB,KACvB,IAmBS,AAAQ,AAzBT,AAAK,EAAI,GAAK,IAAd,QAyBiB,AAzBjB,AAAK,EAAI,GAAK,IAAd,QAyByB,MArBxB,UAAM,IAAb,KAAqB,KACd,UAAM,IAAb,KAAqB,KAmBnB,YAhEX,AAtCQ,IAuCR,AAeI,AAfQ,AAmCG,AAAK,EAAK,IAAV,WApBP,KACN,AAAU,KAEV,AAAU,OAjBL,AAAI,AAsCI,AAAK,EAAI,GAAK,IAAd,YAtCf,EACE,AAAI,EAAI,KACN,AA1CI,IA2CJ,AAWA,AAXY,AA+BD,AAAK,EAAK,IAAV,WApBP,KACN,AAAU,KAEV,AAAU,MAZR,AA7CI,MA8CJ,AAQA,AARY,GAQR,KACN,AAAU,KAEV,AAAU,aAPZ,AAlDQ,SAgCR,EAAoB,qBAhCpB,AAAQ,YAyHR,AAAI,GAAI,KAAgB,AAAK,AA/Cd,AAAK,AAIL,AAAK,AAAL,AAAK,EAAI,GAAK,IAAd,UAAS,GAAK,IAAd,QAJU,IAAV,QA+CgC,AAAQ,AA/CxC,AAAK,EAAK,IAAV,QA+CqD,EAAG,QACvE,AAAI,GAAI,KAAgB,AAAM,AAAK,EAAG,IAAI,EAAG,MAC7C,AAAI,OAAK,KAAe,AAAwB,EAAU,EAAlC,AAjDT,AAAK,EAAK,IAAV,QAiDmB,AAjDnB,AAAK,AAIL,AAAK,EAAI,GAAK,IAAd,QAJU,IAAV,YAkDf,AAAI,OAAK,KAAoB,AAlDd,AAAK,EAAK,IAAV,UAkDsB,AAlDtB,AAAK,AAIL,AAAK,EAAI,GAAK,IAAd,QAJU,IAAV,UAQC,UAAM,IAAb,KAAqB,KACd,UAAM,IAAb,KAAqB,KACvB,IAyCP,AAAI,OAAK,KAAe,AAAiB,EAAJ,EAAb,AAnDT,AAAK,EAAK,IAAV,QAmDkB,MACjC,AAAI,OAAK,KAAe,AApDT,AAAK,AAAL,AAAK,EAAK,IAAV,QAAU,IAAV,UAqDf,AAAI,OAAK,KAAe,AAjDT,AAAK,AAJL,AAAK,EAAK,IAAV,QAIS,GAAK,IAAd,UAkDf,AAAI,OAAK,OA1GT,AAAI,MAAK,KAAmB,KACrB,KA0GP,AAAI,OAAK,KAAgB,KAAI,AA3EzB,AAQQ,AAYG,AAAK,EAAK,IAAV,WApBP,KACN,AAAU,KAEV,AAAU,MAwEiC,AAjIrC,KAiIsD,WAzCvD,GAAI,MAAS,AAAG,AAdR,AAAK,EAAK,IAAV,QAcgB,EAAG,MACd,AAAG,AAXR,AAAK,EAAI,GAAK,IAAd,QAWgB,EAAG,MAPlB,UAAM,IAAb,KAAqB,KACd,UAAM,IAAb,KAAqB,KAKf,AACyB,EALjC,aAmDP,AAAI,GAAK,KACA,AAAM,EAAG,MAClB,AAAI,AA/DW,AAAK,EAAK,IAAV,QA+DD,KACL,AAhEM,AAAK,AAIL,AAAK,EAAI,GAAK,IAAd,QAJU,IAAV,UAiEf,AAAI,IAOJ,AAAI,AANA,AAlEW,AAAK,EAAK,IAAV,QAkED,KACR,AAAM,AA/DG,AAAK,EAAI,GAAK,IAAd,QA+DK,KAEd,AAAM,AArEG,AAAK,EAAK,IAAV,QAqEK,AAAM,AAjEX,AAAK,EAAI,GAAK,IAAd,QAiEmB,IAAI,KAG5B,EAAG,EAAI,AADb,SAEJ,AAAI,IACJ,EAAO,EAAI,MACT,AAAS,AAAK,AAAE,OAAK,IAAZ,KAAoB,AAAQ,AAAK,AAAE,OAAK,IAAZ,eACvC,AAAK,KACE,SASL,AAAK,IACL,AAjKM,IAkKN,AAlKM,IAmKN,AA7GE,AAQQ,EAxCZ,AAAI,MAAK,KAAmB,KACrB,GA4Ic,OA7Gb,KACN,AAAU,KAEV,AAAU,KA2GV,AApKM","sourceRoot":"./release","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│\n│vi: set net ft=c ts=2 sts=2 sw=2 fenc=utf-8                                :vi│\n╞══════════════════════════════════════════════════════════════════════════════╡\n│ Copyright 2020 Justine Alexandra Roberts Tunney                              │\n│                                                                              │\n│ Permission to use, copy, modify, and/or distribute this software for         │\n│ any purpose with or without fee is hereby granted, provided that the         │\n│ above copyright notice and this permission notice appear in all copies.      │\n│                                                                              │\n│ THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL                │\n│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │\n│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │\n│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │\n│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │\n│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │\n│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │\n│ PERFORMANCE OF THIS SOFTWARE.                                                │\n╚─────────────────────────────────────────────────────────────────────────────*/\n\n/*───────────────────────────────────────────────────────────────────────────│─╗\n│ The LISP Challenge § LISP Machine                                        ─╬─│┼\n╚────────────────────────────────────────────────────────────────────────────│*/\n\ntype T = i16;\nconst align = alignof<T>() as T;\n\nconst kT          = 4;\nconst kQuote      = 6;\nconst kCond       = 12;\nconst kRead       = 17;\nconst kPrint      = 22;\nconst kAtom       = 28;\nconst kCar        = 33;\nconst kCdr        = 37;\nconst kCons       = 41;\nconst kEq         = 46;\n\nconst tNewLine    = 10 as u8;\nconst tSpace      = 32 as u8;\nconst tLeftParen  = 40 as u8;\nconst tRightParen = 41 as u8;\nconst tStar       = 42 as u8;\n\nconst M = 0x8000;\n\nlet cx: T; /* stores negative memory use */\nlet dx: u8; /* stores lookahead character */\n\ndeclare function getchar(): i32;\n\ndeclare function putchar(i: i32): void;\n\nfunction Intern(): T {\n  let i: T, j: T, k: T, x: u8;\n  for (i = 0; x = load<u8>(i++, M);) {\n    for (j = 0; x == load<u8>(j); ++j) {\n      if (!x) return i - j - 1;\n      x = load<u8>(i++, M);\n    }\n    while (x)\n      x = load<u8>(i++, M);\n  }\n  j = 0;\n  k = --i;\n  while (x = load<u8>(j++)) store<u8>(i++, x, M);\n  return k;\n}\n\nfunction GetChar(): u8 {\n  let t = dx;\n\n  dx = getchar() as u8;\n  return t;\n}\n\nfunction PrintChar(c: i32): void {\n  putchar(c);\n}\n\nfunction GetToken(): u8 {\n  let c: u8, i: T = 0;\n  do if ((c = GetChar()) > tSpace) store<u8>(i++, c);\n  while (c <= tSpace || (c > tRightParen && dx > tRightParen));\n  store<u8>(i, 0);\n  return c;\n}\n\nfunction AddList(x: T): T {\n  return Cons(x, GetList());\n}\n\nfunction GetList(): T {\n  const c = GetToken();\n  if (c == tRightParen) return 0;\n  return AddList(GetObject(c));\n}\n\nfunction GetObject(c: u8): T {\n  if (c == tLeftParen) return GetList();\n  return Intern();\n}\n\nfunction Read(): T {\n  return GetObject(GetToken());\n}\n\nfunction PrintAtom(x: T): void {\n  let c: u8;\n  while (c = load<u8>(x++, M)) {\n    PrintChar(c);\n  }\n}\n\nfunction PrintList(x: T): void {\n  PrintChar(tLeftParen);\n  PrintObject(Car(x));\n  while (x = Cdr(x)) {\n    if (x < 0) {\n      PrintChar(tSpace);\n      PrintObject(Car(x));\n    } else {\n      PrintChar(0x2219);\n      PrintObject(x);\n      break;\n    }\n  }\n  PrintChar(tRightParen);\n}\n\nfunction PrintObject(x: T): void {\n  if (x < 0) {\n    PrintList(x);\n  } else {\n    PrintAtom(x);\n  }\n}\n\nfunction Print(e: T): void {\n  PrintObject(e);\n}\n\nfunction PrintNewLine(): void {\n  PrintChar(tNewLine);\n}\n\n/*───────────────────────────────────────────────────────────────────────────│─╗\n│ The LISP Challenge § Bootstrap John McCarthy's Metacircular Evaluator    ─╬─│┼\n╚────────────────────────────────────────────────────────────────────────────│*/\n\nfunction Car(x: T): T {\n  return load<T>(M + (x << align));\n}\n\nfunction Cdr(x: T): T {\n  return load<T>(M + (x + 1 << align));\n}\n\nfunction Cons(car: T, cdr: T): T {\n  store<T>(M + (--cx << align), cdr);\n  store<T>(M + (--cx << align), car);\n  return cx;\n}\n\nfunction Gc(x: T, m: T, k: T): T {\n  return x < m ? Cons(Gc(Car(x), m, k), \n                      Gc(Cdr(x), m, k)) + k : x;\n}\n\nfunction Evlis(m: T, a: T): T {\n  if (m) {\n    const x: T = Eval(Car(m), a);\n    return Cons(x, Evlis(Cdr(m), a));\n  } else {\n    return 0;\n  }\n}\n\nfunction Pairlis(x: T, y: T, a: T): T {\n  return x ? Cons(Cons(Car(x), Car(y)),\n                  Pairlis(Cdr(x), Cdr(y), a)) : a;\n}\n\nfunction Assoc(x: T, y: T): T {\n  if (!y) return 0;\n  if (x == Car(Car(y))) return Cdr(Car(y));\n  return Assoc(x, Cdr(y));\n}\n\nfunction Evcon(c: T, a: T): T {\n  if (Eval(Car(Car(c)), a)) {\n    return Eval(Car(Cdr(Car(c))), a);\n  } else {\n    return Evcon(Cdr(c), a);\n  }\n}\n\nfunction Apply(f: T, x: T, a: T): T {\n  if (f < 0)       return Eval(Car(Cdr(Cdr(f))), Pairlis(Car(Cdr(f)), x, a));\n  if (f > kEq)     return Apply(Eval(f, a), x, a);\n  if (f == kEq)    return Car(x) == Car(Cdr(x)) ? kT as T : 0;\n  if (f == kCons)  return Cons(Car(x), Car(Cdr(x)));\n  if (f == kAtom)  return Car(x) < 0 ? 0 : kT as T;\n  if (f == kCar)   return Car(Car(x));\n  if (f == kCdr)   return Cdr(Car(x));\n  if (f == kRead)  return Read();\n  if (f == kPrint) return (x ? Print(Car(x)) : PrintNewLine()), 0;\n  return 0;\n}\n\nfunction Eval(e: T, a: T): T {\n  let A: T, B: T, C: T;\n  if (e >= 0)\n    return Assoc(e, a);\n  if (Car(e) == kQuote)\n    return Car(Cdr(e));\n  A = cx;\n  if (Car(e) == kCond) {\n    e = Evcon(Cdr(e), a);\n  } else {\n    e = Apply(Car(e), Evlis(Cdr(e), a), a);\n  }\n  B = cx;\n  e = Gc(e, A, A - B);\n  C = cx;\n  while (C < B)\n    store<T>(M + (--A << align), load<T>(M + (--B << align)));\n  cx = A;\n  return e;\n}\n\n/*───────────────────────────────────────────────────────────────────────────│─╗\n│ The LISP Challenge § User Interface                                      ─╬─│┼\n╚────────────────────────────────────────────────────────────────────────────│*/\n\nexport function main(): void {\n  for (;;) {\n    cx = 0;\n    PrintChar(tStar);\n    PrintChar(tSpace);\n    Print(Eval(Read(), 0));\n    PrintNewLine();\n  }\n}"]}